# Lock-Free Hashtable

В этом задании вам необходимо реализовать алгоритм lock-free хеш-таблицы с открытой адресацией. В файле [`src/IntIntHashMap.kt`](src/IntIntHashMap.kt) представлена реализация однопоточной хеш-таблицы с открытой адресацией, которую необходимо доработать.
В процессе выполнения задания вы можете воспользоваться алгоритмом, представленным в [этой статье](https://arxiv.org/pdf/cs/0303011.pdf). Данный алгоритм был рассказан в рамках соответствующей лекции. 

### Подробности
1.	Общий дизайн кода, названия классов и набор публичных методов должны быть оставлены без изменения.
2.	Изначальный размер таблицы (значение поля `INITIAL_CAPACITY`) должен остаться без изменения. Это требуется для корректного тестирования.
3.	Приведенная реализация `IntIntHashMap` имеет один существенный недостаток -- размер таблицы всегда увеличивается в два раза, даже если она была заполнена удаленными элементами. Реальный размер таблицы не проверяется при выборе нового размера в операции **rehash**. Вам не требуется исправлять этот недостаток.
4.	В классе `IntIntHashMap.Core` замените `map: IntArray` на `map: AtomicIntArray`, чтобы вы могли делать над элементами массива операции `map[i].compareAndSet()`, а чтения и записи были _volatile_.
5.	В классе `IntIntHashMap.Core` добавьте переменную `next: AtomicRef<Core>`, которая будет содержать указатель на ядро таблицы большего размера в том случае, когда начато копирование этой таблицы в новую. Потокам, которые одновременно столкнулись с ситуацией `NEEDS_REHASH`, необходимо прийти к консенсусу относительно указателя на новую таблицу с помощью операции `next.compareAndSet(null, newCore)`.
6.	Класс `IntIntHashMap` поддерживает только положительные ключи и значения, строго меньшие `Int.MAX_VALUE`. Используйте старшие биты и значение `Int.MAX_VALUE`, чтобы помечать значения согласно нуждам алгоритма:
    * Новая ячейка будет представлена значением 0.
    * `V'` в нотации лекции или `old(V)` в нотации статьи будет представлено путем выставления старшего бита. 
    * `T` в нотации лекции или `del` в нотации статьи будет представлено значением `Int.MAX_VALUE`.
    * `S` в нотации лекции или done в нотации статьи будет представлено значением `Int.MIN_VALUE`.
7.	Вам не нужно думать об освобождении памяти, об этом позаботится GC. Поэтому, те части алгоритма в статье, где идет рассказ об отслеживании работающих потоков и т.п., вы можете смело пропускать. 

Реализовывать по-настоящему кооперативную операцию **rehash** не требуется, хотя это и очень важно на практике. Для выполнения данного задания допустима описанная в статье реализация, в которой **rehash** начинают и заканчивают те потоки, которые натолкнулись на необходимость его делать, получив результат `NEEDS_REHASH`. Однако, даже те потоки, которые не столкнулись с ситуацией `NEEDS_REHASH`, могут обнаружить, что элементы таблицы, которые они читают или хотят поменять, находятся в процессе переноса или уже перенесены в новое ядро, и должны уметь обрабатывать эту ситуацию без блокировки, помогая завершить незаконченное копирование и повторяя свою операцию в новом ядре.

### Сборка и тестирование

Для проверки вашего решения запустите из корня репозитория:

* `./gradlew build` на Linux или MacOS
* `gradlew build` на Windows